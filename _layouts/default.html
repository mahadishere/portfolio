<!DOCTYPE HTML>
<html>
	<head>
		{% include head.html %}
	</head>
	<body class="is-preload">
		<a href="#main" class="skip-link">Skip to main content</a>
		<button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode">ðŸŒ™</button>
		<button class="music-toggle" onclick="toggleMusic()" aria-label="Toggle background music">ðŸ”‡</button>
		<audio id="background-music" loop>
			<source src="{{ '/assets/audio/background-music.mp3' | relative_url }}" type="audio/mpeg">
			Your browser does not support the audio element.
		</audio>

		<!-- Wrapper-->
			<div id="wrapper">

				<!-- Nav -->
					{% include nav.html %}

				<!-- Main -->
					<div id="main">
						{{ content }}
					</div>

				<!-- Footer -->
					<div id="footer">
						<ul class="copyright">
							<li>&copy; {{ "now" | date: "%Y" }} {{ site.title }}</li>
							<li><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></li>
						</ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="{{ '/assets/js/jquery.min.js' | relative_url }}"></script>
			<script src="{{ '/assets/js/browser.min.js' | relative_url }}"></script>
			<script src="{{ '/assets/js/breakpoints.min.js' | relative_url }}"></script>
			<script src="{{ '/assets/js/util.js' | relative_url }}"></script>
			<script src="{{ '/assets/js/main.js' | relative_url }}"></script>
			<script>
				// Dark mode functionality
				function toggleTheme() {
					const currentTheme = document.documentElement.getAttribute('data-theme');
					const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
					document.documentElement.setAttribute('data-theme', newTheme);
					localStorage.setItem('theme', newTheme);
					updateThemeIcon(newTheme);
				}

				function updateThemeIcon(theme) {
					const button = document.querySelector('.theme-toggle');
					button.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
				}

				// Initialize theme
				const savedTheme = localStorage.getItem('theme') || 'light';
				document.documentElement.setAttribute('data-theme', savedTheme);
				updateThemeIcon(savedTheme);

				// Music functionality
				let musicPlaying = false;
				const audio = document.getElementById('background-music');
				const musicButton = document.querySelector('.music-toggle');

				// Load saved music preference
				const savedMusicState = localStorage.getItem('musicPlaying');
				const shouldAutoPlay = savedMusicState === 'true' || savedMusicState === null; // null = first visit, try autoplay
				
				if (shouldAutoPlay && audio) {
					// Try to autoplay on first visit or if user previously had it playing
					audio.play().then(() => {
						musicPlaying = true;
						localStorage.setItem('musicPlaying', 'true');
						updateMusicIcon(true);
					}).catch(e => {
						// Autoplay blocked - user interaction required
						console.log('Music autoplay blocked. User interaction required to play music.');
						musicPlaying = false;
						if (savedMusicState === null) {
							// First visit - don't save preference yet
						} else {
							localStorage.setItem('musicPlaying', 'false');
						}
						updateMusicIcon(false);
						
						// Try to play on first user interaction
						const playMusicOnInteraction = () => {
							if (audio.paused && shouldAutoPlay) {
								audio.play().then(() => {
									musicPlaying = true;
									localStorage.setItem('musicPlaying', 'true');
									updateMusicIcon(true);
								}).catch(e => console.log('Music play failed:', e));
							}
						};
						
						// Listen for first user interaction
						document.addEventListener('click', playMusicOnInteraction, { once: true });
						document.addEventListener('scroll', playMusicOnInteraction, { once: true });
						document.addEventListener('touchstart', playMusicOnInteraction, { once: true });
					});
				} else if (savedMusicState === 'false') {
					// User explicitly turned it off
					musicPlaying = false;
					updateMusicIcon(false);
				}

				function toggleMusic() {
					if (musicPlaying) {
						audio.pause();
						musicPlaying = false;
						localStorage.setItem('musicPlaying', 'false');
						updateMusicIcon(false);
					} else {
						audio.play().then(() => {
							musicPlaying = true;
							localStorage.setItem('musicPlaying', 'true');
							updateMusicIcon(true);
						}).catch(e => {
							console.log('Error playing music:', e);
							musicPlaying = false;
							updateMusicIcon(false);
						});
					}
				}

				function updateMusicIcon(playing) {
					if (musicButton) {
						musicButton.textContent = playing ? 'ðŸ”Š' : 'ðŸ”‡';
						musicButton.setAttribute('aria-label', playing ? 'Pause background music' : 'Play background music');
					}
				}

				// Update icon when audio state changes (e.g., when audio ends or errors)
				if (audio) {
					audio.addEventListener('play', () => {
						musicPlaying = true;
						updateMusicIcon(true);
					});
					audio.addEventListener('pause', () => {
						musicPlaying = false;
						updateMusicIcon(false);
					});
					audio.addEventListener('ended', () => {
						musicPlaying = false;
						updateMusicIcon(false);
					});
				}

				// Ensure intro video plays (handle autoplay restrictions)
				document.addEventListener('DOMContentLoaded', function() {
					const introVideo = document.querySelector('#home .pic video');
					if (introVideo) {
						// Try to play the video
						introVideo.play().catch(e => {
							// Autoplay was blocked - this is normal in some browsers
							// The video will play when user interacts with the page
							console.log('Video autoplay blocked, will play on user interaction');
						});
						
						// Play video on any user interaction (click, scroll, etc.)
						const playVideo = () => {
							if (introVideo.paused) {
								introVideo.play().catch(e => console.log('Video play failed:', e));
							}
						};
						
						// Listen for user interactions
						document.addEventListener('click', playVideo, { once: true });
						document.addEventListener('scroll', playVideo, { once: true });
						document.addEventListener('touchstart', playVideo, { once: true });
					}
				});

				// Toggle #main width based on active panel
				function updateMainWidth() {
					const main = document.getElementById('main');
					if (!main) return;
					
					// Check hash first for immediate feedback
					const hash = window.location.hash || '';
					const isHomePanel = hash === '#home' || hash === '' || hash === '#';
					
					if (isHomePanel) {
						// Also verify the panel is actually visible
						const introPanel = main.querySelector('.panel.intro');
						if (introPanel) {
							main.classList.add('has-intro');
							return;
						}
					}
					
					// Check for active intro panel (not inactive and visible)
					const introPanel = main.querySelector('.panel.intro');
					const isIntroActive = introPanel && 
						!introPanel.classList.contains('inactive') && 
						introPanel.style.display !== 'none' &&
						introPanel.offsetParent !== null; // Check if actually visible
					
					if (isIntroActive) {
						main.classList.add('has-intro');
					} else {
						main.classList.remove('has-intro');
					}
				}

				// Listen for hash changes and panel switches
				window.addEventListener('hashchange', function() {
					// Immediate check based on hash
					updateMainWidth();
					// Also check after panel transition completes (main.js uses 250ms + 500ms delays)
					setTimeout(updateMainWidth, 100);
					setTimeout(updateMainWidth, 300);
					setTimeout(updateMainWidth, 800); // After full transition
				});
				
				// Use MutationObserver to watch for panel class and style changes
				document.addEventListener('DOMContentLoaded', function() {
					// Initial check
					setTimeout(updateMainWidth, 100);
					
					const main = document.getElementById('main');
					if (main) {
						const observer = new MutationObserver(function(mutations) {
							// Debounce rapid changes
							clearTimeout(observer.timeout);
							observer.timeout = setTimeout(function() {
								updateMainWidth();
							}, 50);
						});
						
						const panels = main.querySelectorAll('.panel');
						panels.forEach(function(panel) {
							// Watch for class changes
							observer.observe(panel, { 
								attributes: true, 
								attributeFilter: ['class'],
								attributeOldValue: false
							});
							// Watch for style/display changes
							observer.observe(panel, { 
								attributes: true, 
								attributeFilter: ['style'],
								attributeOldValue: false
							});
						});
					}
				});

				// Multi-dimensional project filters and search
				document.addEventListener('DOMContentLoaded', function() {
					const xrFilter = document.getElementById('filter-xr');
					const domainFilter = document.getElementById('filter-domain');
					const typeFilter = document.getElementById('filter-type');
					const searchBox = document.getElementById('project-search');
					const resetBtn = document.getElementById('reset-filters');
					const projectCards = document.querySelectorAll('.project-card');
					const resultsCount = document.getElementById('filter-results-count');
					const megaLinks = document.querySelectorAll('.mega-menu a[data-filter-kind]');
					const workToggle = document.querySelector('.nav-item-work > a');
					const workLink = document.querySelector('.nav-item-work > a.work-link');
					// Internal state to support filtering even if dropdowns are hidden
					let xrState = 'all';
					let domainState = 'all';
					let typeState = 'all';
					let gameState = 'all';
					let virtualTourState = 'all';
					let visualization3dState = 'all';
					let modelling3dState = 'all';
					let aiMlState = 'all';
					let cvState = 'all';

					// Add event listeners to all filters
					if (xrFilter) xrFilter.addEventListener('change', applyFilters);
					if (domainFilter) domainFilter.addEventListener('change', applyFilters);
					if (typeFilter) typeFilter.addEventListener('change', applyFilters);
					if (searchBox) searchBox.addEventListener('input', applyFilters);
					if (resetBtn) {
						resetBtn.addEventListener('click', function() {
							if (xrFilter) xrFilter.value = 'all'; else xrState = 'all';
							if (domainFilter) domainFilter.value = 'all'; else domainState = 'all';
							if (typeFilter) typeFilter.value = 'all'; else typeState = 'all';
							gameState = 'all';
							virtualTourState = 'all';
							visualization3dState = 'all';
							modelling3dState = 'all';
							aiMlState = 'all';
							cvState = 'all';
							if (searchBox) searchBox.value = '';
							applyFilters();
						});
					}

					// Expose helper to set filters from anywhere (e.g., mega menu, deep links)
					function applyProjectFiltersFromObject(filters) {
						if (!filters) return;
						if (typeof filters.xr !== 'undefined') {
							if (xrFilter) xrFilter.value = filters.xr || 'all';
							xrState = filters.xr || 'all';
						}
						if (typeof filters.domain !== 'undefined') {
							if (domainFilter) domainFilter.value = filters.domain || 'all';
							domainState = filters.domain || 'all';
						}
						if (typeof filters.type !== 'undefined') {
							if (typeFilter) typeFilter.value = filters.type || 'all';
							typeState = filters.type || 'all';
						}
						if (typeof filters.game !== 'undefined') gameState = filters.game || 'all';
						if (typeof filters['virtual-tour'] !== 'undefined') virtualTourState = filters['virtual-tour'] || 'all';
						if (typeof filters['3d-visualization'] !== 'undefined') visualization3dState = filters['3d-visualization'] || 'all';
						if (typeof filters['3d-modelling'] !== 'undefined') modelling3dState = filters['3d-modelling'] || 'all';
						if (typeof filters['ai-ml'] !== 'undefined') aiMlState = filters['ai-ml'] || 'all';
						if (typeof filters.cv !== 'undefined') cvState = filters.cv || 'all';
						if (searchBox && typeof filters.q !== 'undefined') searchBox.value = filters.q || '';
						applyFilters();
					}
					window.applyProjectFilters = applyProjectFiltersFromObject;

					// Mega menu link handling
					if (megaLinks && megaLinks.length) {
						megaLinks.forEach(link => {
							link.addEventListener('click', function(e) {
								e.preventDefault();
								const kind = this.getAttribute('data-filter-kind'); // xr | domain | type | game | virtual-tour | 3d-visualization | 3d-modelling | ai-ml | cv
								const value = this.getAttribute('data-filter-value');
								const pending = {};
								if (kind === 'xr') pending.xr = value;
								if (kind === 'domain') pending.domain = value;
								if (kind === 'type') pending.type = value;
								if (kind === 'game') pending.game = value;
								if (kind === 'virtual-tour') pending['virtual-tour'] = value;
								if (kind === '3d-visualization') pending['3d-visualization'] = value;
								if (kind === '3d-modelling') pending['3d-modelling'] = value;
								if (kind === 'ai-ml') pending['ai-ml'] = value;
								if (kind === 'cv') pending.cv = value;
								// If we're already on #work, apply immediately; else store and navigate
								if (location.hash.indexOf('#work') === 0) {
									applyProjectFiltersFromObject({
										xr: pending.xr || 'all',
										domain: pending.domain || 'all',
										type: pending.type || 'all',
										game: pending.game || 'all',
										'virtual-tour': pending['virtual-tour'] || 'all',
										'3d-visualization': pending['3d-visualization'] || 'all',
										'3d-modelling': pending['3d-modelling'] || 'all',
										'ai-ml': pending['ai-ml'] || 'all',
										cv: pending.cv || 'all'
									});
									try { sessionStorage.removeItem('pendingFilters'); } catch (_) {}
								} else {
									try { sessionStorage.setItem('pendingFilters', JSON.stringify(pending)); } catch (_) {}
									location.hash = '#work';
								}
								if (workToggle) workToggle.setAttribute('aria-expanded', 'false');
						});
					});
					}

					// Toggle aria-expanded based on hover/focus state for a11y
					if (workToggle) {
						const workItem = workToggle.closest('.nav-item-work');
						if (workItem) {
							workItem.addEventListener('mouseenter', () => workToggle.setAttribute('aria-expanded', 'true'));
							workItem.addEventListener('mouseleave', () => workToggle.setAttribute('aria-expanded', 'false'));
							workItem.addEventListener('focusin', () => workToggle.setAttribute('aria-expanded', 'true'));
							workItem.addEventListener('focusout', () => workToggle.setAttribute('aria-expanded', 'false'));
						}
					}

					// Clicking Work clears filters and shows the Work panel with featured projects
					if (workLink) {
						workLink.addEventListener('click', function() {
							// reset internal states
							xrState = 'all';
							domainState = 'all';
							typeState = 'all';
							gameState = 'all';
							virtualTourState = 'all';
							visualization3dState = 'all';
							modelling3dState = 'all';
							aiMlState = 'all';
							cvState = 'all';
							// reset dropdowns if present
							if (xrFilter) xrFilter.value = 'all';
							if (domainFilter) domainFilter.value = 'all';
							if (typeFilter) typeFilter.value = 'all';
							if (searchBox) searchBox.value = '';
							try { sessionStorage.removeItem('pendingFilters'); } catch (_) {}
							// ensure hash is clean (#work without query)
							setTimeout(() => {
								if (location.hash.indexOf('#work') !== 0) {
									location.hash = '#work';
								} else if (location.hash !== '#work') {
									history.replaceState(null, '', '#work');
								}
								applyFilters();
							}, 0);
						});
					}

					// Multi-dimensional filtering function
					function applyFilters() {
						const xrValue = xrFilter ? xrFilter.value : xrState;
						const domainValue = domainFilter ? domainFilter.value : domainState;
						const typeValue = typeFilter ? typeFilter.value : typeState;
						const gameValue = gameState;
						const virtualTourValue = virtualTourState;
						const visualization3dValue = visualization3dState;
						const modelling3dValue = modelling3dState;
						const aiMlValue = aiMlState;
						const cvValue = cvState;
						const searchTerm = searchBox ? searchBox.value.toLowerCase() : '';
						const noActiveFilters = (xrValue === 'all' && domainValue === 'all' && typeValue === 'all' && gameValue === 'all' && virtualTourValue === 'all' && visualization3dValue === 'all' && modelling3dValue === 'all' && aiMlValue === 'all' && cvValue === 'all' && searchTerm === '');

						let visibleCount = 0;
						let totalCount = 0;

						projectCards.forEach(card => {
							totalCount++;
							
							// Get card data attributes
							const cardXR = card.getAttribute('data-xr') || 'none';
							const cardDomains = (card.getAttribute('data-domain') || 'none').split(',');
							const cardTypes = (card.getAttribute('data-type') || 'none').split(',');
							const cardGame = card.getAttribute('data-game') || 'none';
							const cardVirtualTour = card.getAttribute('data-virtual-tour') || 'none';
							const cardVisualization3d = card.getAttribute('data-3d-visualization') || 'none';
							const cardModelling3d = card.getAttribute('data-3d-modelling') || 'none';
							const cardAiMl = card.getAttribute('data-ai-ml') || 'none';
							const cardCv = card.getAttribute('data-cv') || 'none';
							const cardFeatured = (card.getAttribute('data-featured') || 'false') === 'true';
							const cardTags = card.getAttribute('data-tags') || '';
							const cardTitle = card.getAttribute('data-title') || '';
							const cardSummary = card.getAttribute('data-summary') || '';

							// Check XR technology filter
							const matchesXR = xrValue === 'all' || cardXR === xrValue;

							// Check domain filter (project can have multiple domains)
							const matchesDomain = domainValue === 'all' || 
								cardDomains.includes(domainValue) ||
								cardDomains.includes('none');

							// Check type filter (project can have multiple types)
							const matchesType = typeValue === 'all' || 
								cardTypes.includes(typeValue) ||
								cardTypes.includes('none');

							// Check game filter
							const matchesGame = gameValue === 'all' || cardGame === gameValue;

							// Check virtual tour filter
							const matchesVirtualTour = virtualTourValue === 'all' || cardVirtualTour === virtualTourValue;

							// Check 3D visualization filter
							const matchesVisualization3d = visualization3dValue === 'all' || cardVisualization3d === visualization3dValue;

							// Check 3D modelling filter
							const matchesModelling3d = modelling3dValue === 'all' || cardModelling3d === modelling3dValue;

							// Check AI/ML filter
							const matchesAiMl = aiMlValue === 'all' || cardAiMl === aiMlValue;

							// Check CV filter
							const matchesCv = cvValue === 'all' || cardCv === cvValue;

							// Check search term
							const matchesSearch = searchTerm === '' || 
								cardTitle.includes(searchTerm) ||
								cardSummary.includes(searchTerm) ||
								cardTags.includes(searchTerm);

							// Show card only if it matches ALL active filters (AND logic)
							// Special rule: when no filters are active, show only featured projects
							const passesFeaturedRule = noActiveFilters ? cardFeatured : true;

							if (matchesXR && matchesDomain && matchesType && matchesGame && matchesVirtualTour && matchesVisualization3d && matchesModelling3d && matchesAiMl && matchesCv && matchesSearch && passesFeaturedRule) {
								card.style.display = 'block';
								visibleCount++;
							} else {
								card.style.display = 'none';
							}
						});

						// Update results count
						if (resultsCount) {
							if (visibleCount === totalCount) {
								resultsCount.textContent = `Showing all ${totalCount} projects`;
							} else {
								resultsCount.textContent = `Showing ${visibleCount} of ${totalCount} projects`;
							}
						}
					}

					// Deep-linking: parse hash like #work?xr=AR&domain=Medical&type=Game&q=search
					function syncFiltersFromHash() {
						const hash = location.hash || '';
						if (!hash.includes('#work')) return;
						const qIndex = hash.indexOf('?');
						if (qIndex === -1) {
							// No query: apply pending filters if present, else default
							let pending = null;
							try { pending = JSON.parse(sessionStorage.getItem('pendingFilters') || 'null'); } catch (_) {}
							if (pending) {
								applyProjectFiltersFromObject({
									xr: pending.xr || 'all',
									domain: pending.domain || 'all',
									type: pending.type || 'all',
									game: pending.game || 'all',
									'virtual-tour': pending['virtual-tour'] || 'all',
									'3d-visualization': pending['3d-visualization'] || 'all',
									'3d-modelling': pending['3d-modelling'] || 'all',
									'ai-ml': pending['ai-ml'] || 'all',
									cv: pending.cv || 'all'
								});
								try { sessionStorage.removeItem('pendingFilters'); } catch (_) {}
							} else {
								applyFilters();
							}
							return;
						}
						const qs = hash.substring(qIndex + 1);
						const params = new URLSearchParams(qs);
						applyProjectFiltersFromObject({
							xr: params.get('xr') || 'all',
							domain: params.get('domain') || 'all',
							type: params.get('type') || 'all',
							game: params.get('game') || 'all',
							'virtual-tour': params.get('virtual-tour') || 'all',
							'3d-visualization': params.get('3d-visualization') || 'all',
							'3d-modelling': params.get('3d-modelling') || 'all',
							'ai-ml': params.get('ai-ml') || 'all',
							cv: params.get('cv') || 'all',
							q: params.get('q') || ''
						});
					}
					window.addEventListener('hashchange', syncFiltersFromHash);

					// Initial filter application (respect deep links)
					syncFiltersFromHash();

					// ----- Faux scrollbar sync for mega menu -----
					const catScroller = document.querySelector('.mega-categories');
					const track = document.querySelector('.mega-scrollbar');
					const thumb = document.querySelector('.mega-scrollbar-thumb');

					function updateThumb() {
						if (!catScroller || !track || !thumb) return;
						const visible = catScroller.clientWidth;
						const total = catScroller.scrollWidth;
						const trackW = track.clientWidth;
						const ratio = Math.max(visible / total, 0.05);
						const thumbW = Math.max(trackW * ratio, 20);
						const maxLeft = trackW - thumbW;
						const scrollRatio = catScroller.scrollLeft / (total - visible || 1);
						const left = maxLeft * scrollRatio;
						thumb.style.width = `${thumbW}px`;
						thumb.style.transform = `translateX(${left}px)`;
					}

					let dragging = false;
					let dragStartX = 0;
					let dragStartLeft = 0;

					function onThumbDown(e) {
						dragging = true;
						dragStartX = e.clientX;
						const matrix = new DOMMatrix(getComputedStyle(thumb).transform);
						dragStartLeft = matrix.m41 || 0;
						e.preventDefault();
					}
					function onMove(e) {
						if (!dragging) return;
						const trackW = track.clientWidth;
						const thumbW = thumb.clientWidth;
						const maxLeft = trackW - thumbW;
						let left = Math.min(Math.max(dragStartLeft + (e.clientX - dragStartX), 0), maxLeft);
						thumb.style.transform = `translateX(${left}px)`;
						// Map thumb to scrollLeft
						const total = catScroller.scrollWidth;
						const visible = catScroller.clientWidth;
						const scrollMax = total - visible;
						catScroller.scrollLeft = (left / maxLeft) * scrollMax;
					}
					function onUp() { dragging = false; }

					function onTrackClick(e) {
						if (e.target === thumb) return; // handled by drag
						const rect = track.getBoundingClientRect();
						const clickX = e.clientX - rect.left;
						const total = catScroller.scrollWidth;
						const visible = catScroller.clientWidth;
						const trackW = track.clientWidth;
						const targetRatio = clickX / trackW;
						catScroller.scrollLeft = targetRatio * (total - visible);
					}

					if (catScroller && track && thumb) {
						catScroller.addEventListener('scroll', updateThumb, { passive: true });
						window.addEventListener('resize', updateThumb);
						thumb.addEventListener('mousedown', onThumbDown);
						window.addEventListener('mousemove', onMove);
						window.addEventListener('mouseup', onUp);
						track.addEventListener('mousedown', onTrackClick);
						// Update when menu opens (hover)
						const workItem = document.querySelector('.nav-item-work');
						if (workItem) {
							workItem.addEventListener('mouseenter', updateThumb);
							workItem.addEventListener('focusin', updateThumb);
						}
						updateThumb();
					}
				});
			</script>

	</body>
</html>

